# -*- coding: utf-8 -*-
"""ordis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EsbhLm0K8PV2pStdNMsm1KY1g1hE4vE6
"""

!pip install discord.py requests python-dotenv nest_asyncio

import os

# Wpisz tutaj swoje dane
os.environ["DISCORD_BOT_TOKEN"] = "MTMyNDMyNDc1MDgwOTYzMjgxMw.GQmkRr.JQLtj9VX3QbfBw7XyxgZ7tb4y5XCgK6cQMNZFo"
os.environ["DISCORD_CHANNEL_ID"] = "395627855544975362"

async def fetch_warframe_cycles():
    """ Pobiera aktualne dane o cyklach Warframe. """
    try:
        response = requests.get("https://api.warframestat.us/pc")
        if response.status_code == 200:
            data = response.json()
            print("Dane zwrÃ³cone przez API:", data)  # Debugowanie
            return data
        else:
            print(f"BÅ‚Ä…d: API zwrÃ³ciÅ‚o status {response.status_code}")
            return None
    except Exception as e:
        print(f"BÅ‚Ä…d pobierania danych: {e}")
        return None

import discord
import requests
import asyncio
import os
from datetime import datetime, timedelta, timezone
import random
import nest_asyncio

nest_asyncio.apply()

TOKEN = os.getenv("DISCORD_BOT_TOKEN")
CHANNEL_ID = int(os.getenv("DISCORD_CHANNEL_ID"))
API_URL = "https://api.warframestat.us/pc"

intents = discord.Intents.default()
client = discord.Client(intents=intents)

welcome_messages = [
    "Systemy dziaÅ‚ajÄ… optymalnie! OTC, gotowi do dziaÅ‚ania! Czas siaÄ‡ chaos... znaczyâ€¦ ratowaÄ‡ system Origin!",
    "Ordis online! Witajcie, Tenno Sojuszu OTC! Czy jesteÅ›cie gotowi na kolejne misje? Mam nadziejÄ™, Å¼e nie bÄ™dzie zbyt duÅ¼oâ€¦ destrukcji.",
    "Ordis wita lojalnych Tenno! Wszystko gotowe na kolejne zadanie. Mam nadziejÄ™, Å¼e tym razem unikniemy katastrofyâ€¦ ale kto wie!",
    "Sojusz OTC online! O, jakÅ¼e ekscytujÄ…ce! Misje czekajÄ…, Warframeâ€™y gotowe, a Ordisâ€¦ trochÄ™ siÄ™ martwi.",
    "Hej, Tenno! Dzisiaj w planie: wielkie bitwy, niesamowite nagrody iâ€¦ minimalna liczba awarii, mam nadziejÄ™!",
    "Analiza systemÃ³w zakoÅ„czona! OTC w peÅ‚nej gotowoÅ›ci! CzekajÄ… nas niebezpieczne misjeâ€¦ ale Ordis jest z wami!",
    "DzieÅ„ dobry, wojownicy! BroÅ„ naÅ‚adowana, misje czekajÄ…. Mam nadziejÄ™, Å¼e nie bÄ™dzie Å¼adnychâ€¦ niefortunnych wypadkÃ³w!",
    "Ordis melduje peÅ‚nÄ… sprawnoÅ›Ä‡! Tenno, system Origin wzywa! Mam nadziejÄ™, Å¼e to bÄ™dzie miÅ‚y dzieÅ„ bezâ€¦ rozkÅ‚adu molekularnego.",
    "Oâ€¦ Oâ€¦ OCH! TENNO! To siÄ™ dzieje! WÃ³dz OTC przybyÅ‚! AnalizujÄ™â€¦ tak, to na pewno ON! Ordis jestâ€¦ podekscytowany! Wszyscy na bacznoÅ›Ä‡! Czy mam uruchomiÄ‡ fanfary? Nie? Dobrzeâ€¦ ale i tak to ekscytujÄ…ce! ChwaÅ‚a OTC i naszym Wodzom!"
]

def format_time(time_str):
    """ Konwertuje czas z formatu API na dynamiczne odliczanie. """
    try:
        expiry_time = datetime.strptime(time_str, "%Y-%m-%dT%H:%M:%S.%fZ").replace(tzinfo=timezone.utc)
        now = datetime.utcnow().replace(tzinfo=timezone.utc)
        time_left = expiry_time - now

        if time_left.total_seconds() <= 0:
            return "ZakoÅ„czone"

        hours, remainder = divmod(int(time_left.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)

        return f"{hours}h {minutes}m {seconds}s"
    except Exception as e:
        print(f"BÅ‚Ä…d formatowania czasu: {e}")
        return "Brak danych"

async def fetch_warframe_data():
    """ Pobiera aktualne dane z API Warframe. """
    try:
        response = requests.get(API_URL)
        if response.status_code == 200:
            data = response.json()
            print("Dane pobrane z API:", data)  # Debugowanie pobranych danych
            return data
        else:
            print(f"BÅ‚Ä…d: API zwrÃ³ciÅ‚o status {response.status_code}")
            return None
    except Exception as e:
        print(f"BÅ‚Ä…d pobierania danych: {e}")
        return None

async def update_cycle_message():
    """ Tworzy lub aktualizuje wiadomoÅ›Ä‡ z cyklami Warframe i dodatkowymi wydarzeniami. """
    await client.wait_until_ready()
    channel = client.get_channel(CHANNEL_ID)

    if not channel:
        print("Nie znaleziono kanaÅ‚u!")
        return

    message = None

    while not client.is_closed():
        data = await fetch_warframe_data()
        if data:
            sortie = data.get('sortie', {})
            archon_hunt = data.get('archonHunt', {})
            void_trader = data.get('voidTrader', {})
            events = data.get('events', [])

            welcome_message = random.choice(welcome_messages)

            cycle_info = (
                f"{welcome_message}\n\n"
                f"ðŸŒ **Ziemia**: {'â˜€ï¸ DzieÅ„' if data.get('earthCycle', {}).get('isDay', False) else 'ðŸŒ™ Noc'} - {data.get('earthCycle', {}).get('timeLeft', 'Brak danych')}\n"
                f"ðŸŒž **Cetus**: {'â˜€ï¸ DzieÅ„' if data.get('cetusCycle', {}).get('isDay', False) else 'ðŸŒ™ Noc'} - {data.get('cetusCycle', {}).get('timeLeft', 'Brak danych')}\n"
                f"ðŸ”¥ **Vallis**: {data.get('vallisCycle', {}).get('state', 'Brak danych')} - {data.get('vallisCycle', {}).get('timeLeft', 'Brak danych')}\n"
                f"ðŸ’€ **ÅšcieÅ¼ka Stali**: {data.get('steelPath', {}).get('currentReward', {}).get('name', 'Brak danych')} - {format_time(data.get('steelPath', {}).get('expiry', 'Brak danych'))}\n"
                f"ðŸ“Œ **ArbitraÅ¼**: {data.get('arbitration', {}).get('node', 'Brak danych')} - {data.get('arbitration', {}).get('enemy', 'Brak danych')}\n"
                f"ðŸ›°ï¸ **Zariman**: {data.get('zarimanCycle', {}).get('state', 'Brak danych')} - {data.get('zarimanCycle', {}).get('timeLeft', 'Brak danych')}\n"
                "\n"
                f"ðŸŽ¯ **Sortie**: {sortie.get('boss', 'Brak danych')} - {format_time(sortie.get('expiry', 'Brak danych'))}\n"
                f"ðŸ”± **Polowanie na Archona**: {archon_hunt.get('boss', 'Brak danych')} - {format_time(archon_hunt.get('expiry', 'Brak danych'))}\n"
                f"ðŸ’° **Handlarz Void**: {void_trader.get('location', 'Brak danych')} - {'Przybywa za: ' + format_time(void_trader.get('start', 'Brak danych')) if not void_trader.get('active', False) else 'Jest juÅ¼ dostÄ™pny!'}\n"
                "\n"
                "**ðŸ›¡ï¸ Wydarzenia specjalne:**\n"
            )

            for event in events:
                cycle_info += f"ðŸŽ‰ **{event.get('description', 'Brak nazwy')}** - {format_time(event.get('expiry', 'Brak danych'))} - {event.get('health', 'Brak danych')}% ukoÅ„czenia\n"

            if message is None:
                message = await channel.send(cycle_info)
            else:
                await message.edit(content=cycle_info)

        await asyncio.sleep(30)  # Aktualizacja co minutÄ™

@client.event
async def on_ready():
    print(f'Zalogowano jako {client.user}')
    client.loop.create_task(update_cycle_message())

async def main():
    await client.start(TOKEN)

asyncio.run(main())